<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>File Sharing App</title>
    <style>
      #progress-container {
        width: 100%;
        background-color: #f3f3f3;
        margin-top: 20px;
      }
      #progress-bar {
        width: 0%;
        height: 30px;
        background-color: #4caf50;
        text-align: center;
        line-height: 30px;
        color: white;
      }
    </style>
  </head>
  <body>
    <h1>Your name: <span id="client-name"><%= clientName %></span></h1>
    <h2>Connected Clients (Same Public IP):</h2>
    <ul id="clients-list"></ul>
    <h2>Send a File</h2>
    <input type="file" id="file-input" />
    <select id="recipient-select">
      <option value="" disabled selected>Select a client</option>
    </select>
    <button id="send-button">Send File</button>
    <div id="progress-container">
      <div id="progress-bar">0%</div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const clientName = "<%= clientName %>";
      const socket = io({ query: { client_name: clientName } });
      const clientsList = document.getElementById("clients-list");
      const recipientSelect = document.getElementById("recipient-select");
      const fileInput = document.getElementById("file-input");
      const sendButton = document.getElementById("send-button");
      const progressBar = document.getElementById("progress-bar");

      const CHUNK_SIZE = 1024 * 64; // 64KB per chunk

      // Function to fetch public IP address
      async function getPublicIP() {
        try {
          const response = await fetch("https://api.ipify.org?format=json");
          const data = await response.json();
          return data.ip; // Returns the public IP address
        } catch (error) {
          console.error("Error fetching public IP:", error);
          return null; // Handle error case
        }
      }

      // Register public IP with the server
      getPublicIP().then((publicIP) => {
        socket.emit("register_public_ip", { publicIP, clientName });
      });

      socket.on("update_clients", function (clients) {
        clientsList.innerHTML = "";
        recipientSelect.innerHTML =
          '<option value="" disabled selected>Select a client</option>';
        clients.forEach((client) => {
          const li = document.createElement("li");
          li.textContent = client;
          clientsList.appendChild(li);
          if (client !== clientName) {
            const option = document.createElement("option");
            option.value = client;
            option.textContent = client;
            recipientSelect.appendChild(option);
          }
        });
      });

      sendButton.addEventListener("click", function () {
        const file = fileInput.files[0];
        if (file && recipientSelect.value) {
          const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
          let currentChunk = 0;

          function updateProgress(percentage) {
            progressBar.style.width = percentage + "%";
            progressBar.textContent = Math.round(percentage) + "%";
          }

          function sendNextChunk() {
            const start = currentChunk * CHUNK_SIZE;
            const end = Math.min(start + CHUNK_SIZE, file.size);
            const chunk = file.slice(start, end);

            const reader = new FileReader();
            reader.onload = function (e) {
              const base64Chunk = e.target.result.split(",")[1]; // Extract Base64 data
              socket.emit("send_file_chunk", {
                recipient: recipientSelect.value,
                chunk: base64Chunk,
                file_name: file.name,
                chunk_index: currentChunk,
                total_chunks: totalChunks,
              });
              currentChunk++;
              updateProgress((currentChunk / totalChunks) * 100);
              if (currentChunk < totalChunks) {
                sendNextChunk();
              }
            };
            reader.readAsDataURL(chunk);
          }

          sendNextChunk();
        }
      });

      socket.on("receive_file_chunk", function (data) {
        const { chunk, file_name, chunk_index, total_chunks } = data;

        if (!window.receivedChunks) {
          window.receivedChunks = [];
        }

        if (chunk_index === 0) {
          window.receivedChunks = [];
        }

        window.receivedChunks.push(atob(chunk)); // Decode Base64 chunk

        if (chunk_index + 1 === total_chunks) {
          const byteArray = new Uint8Array(
            window.receivedChunks
              .join("")
              .split("")
              .map((c) => c.charCodeAt(0))
          );
          const blob = new Blob([byteArray], {
            type: "application/octet-stream",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = file_name;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          window.receivedChunks = null;
        }
      });

      socket.on("transfer_error", function (data) {
        alert(data.message);
      });
    </script>
  </body>
</html>
